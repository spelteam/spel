#! /usr/bin/env python2.7

import glob
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import argparse
import numpy as np
import matplotlib.image as mpimg
from matplotlib.lines import Line2D
from pylab import figure, show
import math
import os
import re
import random

def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        return False

def usage():

	print("Author: Mykyta Fastovets / poselib project / 2015")
	print("This utility is an analysis tool for plotting error files generated by the poselib tuners.")
	print("Input should be a .err file.")
	print("Example usage: ./plotSimVsTemp.py ~/file.err ")

def dist(a,b):

	return math.sqrt((a[0]-b[0])**2+(a[1] - b[1])**2)

def parseErrFile(errFile):

	params=[]
	times=[]

	polygons=[]
	errors=[]
	evals=[]
	frameIDs=[]

	data=""
	with open (errFile, "r") as myfile:
		data=myfile.read().replace('\n', '\t')

	pattern = "\{(.*?)\}"
	paramPattern = "\}(.*?)\{"
	firstParamPattern = "\t(.*?)\{"
	match = re.findall(pattern,data)
	paramMatch = re.findall(paramPattern,data)
	firstParamMatch = re.findall(firstParamPattern,data)[0].split('\t')[-2]
	#print len(match)
	firstParamMatch = firstParamMatch.split()
	params.append(firstParamMatch[0])
	times.append(firstParamMatch[1])

	for p in paramMatch:
		p=p.split()
		params.append(p[0])
		times.append(p[1])

	for m in match:
		frames=m.strip().split('\t') #split by frames

		paramErrors=[] #all errors at this param level
		paramPolygons=[] #all polygons at this param level
		paramEvals=[] #all eval scores at this param level
		paramFrames=[]

		#print frames[0]

		for frame in frames:

			frame = frame.split()
			#print frame
			#frameID evalScore limb1RMS (limb1Poly) limb2RMS (limb2Poly) limb3RMS (limb3Poly) limb4RMS (limb4Poly)... limbKRMS (limbKPoly)

			frameID = frame[0]
			frameEval = frame[1]

			frameErrors = []
			framePolygons = []
			i=2
			while i<len(frame):
				frameErrors.append(frame[i])
				i+=1
				polygon = []
				for k in range(4):
					polygon.append((float(frame[i]), float(frame[i+1])))
					i+=2
				framePolygons.append(polygon)

			#print frameErrors
			paramFrames.append(frameID)
			paramEvals.append(frameEval)
			paramErrors.append(frameErrors)
			paramPolygons.append(framePolygons)
		
		polygons.append(paramPolygons)
		errors.append(paramErrors)
		evals.append(paramEvals)
		frameIDs.append(paramFrames)

	return (params, times, frameIDs, errors, evals, polygons)

parser = argparse.ArgumentParser(description='1 non-optional argument')

parser.add_argument('ERRIN', action="store")
parseResult = parser.parse_args()

data = parseErrFile(parseResult.ERRIN)

#data(params, times, frameIDs, errors, evals, polygons)

params = data[0]
times = data[1]
frameIDs = data[2]
errors = data[3]
evals = data[4]
polygons = data[5]

seqName=parseResult.ERRIN.split('_')[-1].split('.')[0]
solverName=parseResult.ERRIN.split('_')[-2]
paramName=parseResult.ERRIN.split('_')[0].split('/')[-1]

print 'Global '+paramName+', '+solverName+', '+seqName

paramRange=5
if is_number(params[-1]):
	paramRange = float(params[-1])-float(params[0])


pcol = [(0.94,0.64,1.0),(0.0,0.46,0.86),(0.6,0.25,0.0),(0.3,0,0.36),(0.1,0.1,0.1),(0,0.36,0.19),(0.17,0.8,0.28),(1,0.8,0.6),
(0.5,0.5,0.5),(0.58,1,0.71),(0.56,0.47,0), (0.6, 0.8, 1.0), (0.25, 0.6, 0.0), (0.86, 0.0, 0.46), (1.0, 1.0, 0.64), (0, 0.5, 1.0), (1.0, 0.5, 0.0)]

fig = plt.figure(1, figsize=(30, 30), dpi=600)

ax = fig.add_subplot(111)#, projection='2d')
ax.yaxis.grid(True, linestyle='-', which='major', color='lightgrey',
              alpha=0.5)
ax.xaxis.grid(True, linestyle='-', which='major', color='lightgrey',
              alpha=0.5)

# fig1 = plt.figure(2, figsize=(30, 30), dpi=600)

# bx = fig1.add_subplot(111)#, projection='2d')
# bx.yaxis.grid(True, linestyle='-', which='major', color='lightgrey',
#               alpha=0.5)
# bx.xaxis.grid(True, linestyle='-', which='major', color='lightgrey',
#               alpha=0.5)

# fig2 = plt.figure(3, figsize=(30, 30), dpi=600)
# cx = fig2.add_subplot(111)#, projection='2d')
# cx.yaxis.grid(True, linestyle='-', which='major', color='lightgrey',
#               alpha=0.5)
# cx.xaxis.grid(True, linestyle='-', which='major', color='lightgrey',
#               alpha=0.5)
# bx = fig.add_subplot(212)#, projection='2d')
# bx.yaxis.grid(True, linestyle='-', which='major', color='lightgrey',
#               alpha=0.5)
# bx.xaxis.grid(True, linestyle='-', which='major', color='lightgrey',
#               alpha=0.5)

#what's interesting for NSKP, is RMS error boxplot and number of lockframes generated

#plot the error graphs for TLPS
partNames=[]
linestyles = ['-', '--', '-.', ':']
for p in range(len(params)): #for each element in params
	
	#there will be a line for each param value
	pFrames=frameIDs[p] #list of frames
	numFrames = len(pFrames)

	frameRMS = [] #the RMS errors
	frameEval = [] #the eval score
	allErrorRatios=[]
	
	numParts=0

	#print numFrames
	for e in range(numFrames):
		partErrs = errors[p][e]
		numParts = len(partErrs)
		rmsErr=0.0
		for pe in range(numParts):
			if pe==0 or pe >5:
				rmsErr+=float(partErrs[pe])

				PCL = dist(polygons[p][e][pe][0], polygons[p][e][pe][1])
				#print PCL
				PCE = math.sqrt(float(partErrs[pe]))
				allErrorRatios.append(float(PCE)/float(PCL))			

		rmsErr=math.sqrt(float(rmsErr)/float(numParts-5))
		#if e>=20:
			#rmsErr=30.0
		#print rmsErr
		frameRMS.append(rmsErr)
		if float(evals[p][e])>0:
			frameEval.append(float(evals[p][e]))
		else:
			frameEval.append(0)
	#now produce the pcp curve for this param setting
	paramPCP=[]
	for i in range(100):
		#compute the pcp score
		pcpScore=0
		for scoreItem in allErrorRatios:
			if scoreItem < 0.01*(i+1):
				pcpScore+=1
		paramPCP.append(float(pcpScore)/float(len(allErrorRatios)))

	#print paramPCP

	#now plot this
	#ax.plot(pFrames, frameRMS, color=pcol[p], alpha=1.0, label=str(params[p]), linewidth=4.0)
	#cx.scatter(frameEval, frameRMS, color=pcol[p], alpha=1.0, label=str(params[p]))
	paramRatio=0
	if is_number(params[p]):
		paramRatio =(float(params[p])-float(params[0]))/float(paramRange)
	else:
		paramRatio =float((len(params))-p)/float(paramRange)
	#print paramRatio
	paramCol = (1.0-paramRatio, 0,paramRatio)
	for i in range(len(paramPCP)):
		paramPCP[i]=paramPCP[i]*len(pFrames)
	ax.plot(range(1,101), paramPCP, color=paramCol, alpha=1.0, label=str(params[p]), linewidth=4.0, linestyle=linestyles[p%4])

plt.rc('legend',**{'fontsize':35})
plt.tick_params(axis='both', which='major', labelsize=35)
plt.tick_params(axis='both', which='minor', labelsize=35)

handles1, labels1 = ax.get_legend_handles_labels()
ax.legend(handles1, labels1)
ax.grid()
ax.legend(title=paramName, loc='upper right', bbox_to_anchor=(1.0, 0.45),
          ncol=1, fancybox=True, shadow=True)
ax.set_xlabel('tau %', fontsize=45)
ax.set_ylabel('PCPF', fontsize=45)
ax.get_legend().get_title().set_fontsize('35')

ax.set_title(paramName+' PCPF-curve\n'+seqName, fontsize=55, y=1.08)

plotSave = parseResult.ERRIN.split('.')[0]+'_solved.png'
fig.savefig(plotSave, bbox_inches='tight')